/*     async saveEmailAddress(emailAddress) {
        const insertEmailAddress = emailAddress.trim();
        // Check if the email address exists in the database.
        const emailAddressModel = await EmailAddressModel.findOne({ 'emailAddress': insertEmailAddress });
        if (emailAddressModel) {
            return SaveStatus.EXISTS;
        }
        let status = null;
        let currentRetries = 0;
        while (status !== SaveStatus.SAVE && currentRetries < this.countsLimitsData.maximumSaveEmailAddressesRetriesCount) {
            try {
                await new EmailAddressModel({ emailAddress: insertEmailAddress }).save();
                status = SaveStatus.SAVE;
            }
            catch (error) {
                status = SaveStatus.ERROR;
                currentRetries++;
            }
            finally {
                await globalUtils.sleep(this.countsLimitsData.millisecondsDelayDatabaseSyncCount);
            }
        }
        return status;
    } */

/*     async dropCollection() {
    let isDropSuccess = false;
    let currentRetries = 0;
    while (!isDropSuccess && currentRetries < this.databaseData.maximumDropCollectionRetriesCount) {
        try {
            await this.client.connection.collection(this.databaseData.mongoCollectionName).drop();
            isDropSuccess = true;
        }
        catch (error) {
            isDropSuccess = false;
            currentRetries++;
        }
    }
} */

/*     async getRandomEmailAddresses() {
        const count = textUtils.getRandomNumber(this.testsData.minimumCreateRandomEmailAddressesCount, this.testsData.maximumCreateRandomEmailAddressesCount);
        const emailAddresses = [];
        while (emailAddresses.length < count) {
            const emailAddress = await this.createEmailAddress();
            if (emailAddress) {
                emailAddresses.push(emailAddress);
            }
        }
        return emailAddresses;
    } */

                /*             while (part.length < maximumLength) {
                            part += randomWords(randomWordsSettings)[0];
                        } */


    /*     removeLastCharacterNotALetterLoop(text) {
            if (!text) {
                return '';
            }
            while (!this.isCharacterALetter(text.charAt(text.length - 1))) {
                text = this.removeLastCharacter(text);
            }
            return text;
        } */

            /*     removeFirstCharacterLoop(data) {
            let { text, character } = data;
            if (!text) {
                return '';
            }
            while (text.charAt(0) === character) {
                text = this.removeFirstCharacter(text);
            }
            return text;
        } */

            /*     removeLastCharacterLoop(data) {
            let { text, character } = data;
            if (!text) {
                return '';
            }
            while (text.charAt(text.length - 1) === character) {
                text = this.removeLastCharacter(text);
            }
            return text;
        } */

        	/* 	fixLocalPartStartWithCommonDomain(validationResult) {
			let { localPart, domainPart, fixed } = this.getEmailAddressData(validationResult);
			for (let i = 0, length = commonEmailAddressDomainsList.length; i < length; i++) {
				const { domain } = commonEmailAddressDomainsList[i];
				while (localPart.indexOf(domain) === 0 && localPart.length > domain.length) {
					localPart = localPart.replace(domain, '');
				}
			}
			validationResult = this.checkEmailAddressUpdate({
				validationResult: validationResult,
				fixed: fixed,
				localPart: localPart,
				domainPart: domainPart,
				functionName: 'fixLocalPartStartWithCommonDomain'
			});
			return validationResult;
		} */


    /*     generateSearchKey() {
            // Generate the search key.
            let resultSearchKey = null;
            if (this.searchData.searchKey) {
                resultSearchKey = this.searchData.searchKey;
            }
            else {
                let currentRetries = 0;
                while (!resultSearchKey && currentRetries < this.countsLimitsData.maximumRetriesGenerateSearchKeyCount) {
                    resultSearchKey = this.searchData.isAdvanceSearchKeys ? this.generateAdvanceKey() : this.generateBasicKey();
                    currentRetries++;
                }
            }
            if (!resultSearchKey) {
                throw new Error('No valid resultSearchKey was created (1000021)');
            }
            // Generate the search key for display by reverse only the UTF-8 keys.
            const resultDisplaySearchKey = this.generateDisplaySearchKey(resultSearchKey);
            return {
                searchKey: resultSearchKey.replace(regexUtils.cleanSpacesRegex, '+'),
                displaySearchKey: resultDisplaySearchKey
            };
        } */