		//debugger;
		//const isPackageName = regexUtils.findPackageNameRegex.test(fixed);
						//const lastDomainEndPart = `.${domainSplits[domainSplits.length - 1]}`;
		//debugger;
/* 			const test = textUtils.addStartDot(textUtils.sliceJoinDots(domainSplits, 1));
	console.log(test); */
							//if (lastDomainEndPart[commonDomainEnd.length] === '.' && isAllowDotAfter)
							//debugger;
/* 					debugger; */
/* 					debugger; */
		//console.log(domainPart);
		//debugger;
/* const emailAddressValidationService = new EmailAddressValidationService();
module.exports = emailAddressValidationService; */
				//console.log(domainPart);
/* 	validateMinimumTotalLength(fixed) {
if (fixed.length < this.emailAddressData.minimumEmailAddressCharactersCount) {
return false;
}
return true;
}

validateExistence(fixed) {
if (!fixed) {
return false;
}
return true;
}

validateAtCharacterExistence(fixed) {
if (fixed.indexOf('@') === -1) {
return false;
}
return true;
}

validateDotCharacterExistence(fixed) {
if (fixed.indexOf('.') === -1) {
return false;
}
return true;
}
*/

//const puppeteerService = require('./puppeteer.service');
//const systemUtils = require('../../utils/files/system.utils');
/* 			console.log(this.pid);
			systemUtils.killProcess(this.pid); */
/* 			// ===BACKUP=== //
			'IS_CREATE_STANDARD_BACKUP', 'IS_CREATE_SECONDARY_BACKUP', */
/* const initiateService = new InitiateService();
module.exports = initiateService; */
		// Kill puppeter.js chromium if still running - Release CPU usage.
/* 		process.on('SIGINT', () => {
			puppeteerService.isUserExit = true;
			puppeteerService.terminateBrowser();
			process.exit(66);
		}); */
		//const puppeteerService = require('./puppeteerService');

/* 		// Kill puppeter.js chromium if still running - Release CPU usage.
		process.on('SIGINT', () => {
			puppeteerService.terminateBrowser(false);
			puppeteerService.close();
			puppeteerService.terminateBrowser();
		}); */

        /*         process.on('SIGKILL', () => {
            this.close();
        }); */

        /*         process.on('message', async (message) => {
                    console.log(1);
                    if (message.action === 'close') {
                        console.log(1);
                        await this.close();
                    }
                }); */
/* const puppeteerService = new PuppeteerService();
module.exports = puppeteerService; */
                //throw new Error('t');
//const timeUtils = require('../../utils/files/time.utils');
        //this.isUserExit = false;
                //this.isUserExit = null;
/*     terminateBrowser() {
        if (this.pid) {
        }
        if (!this.isUserExit) {
        }
    } */
        //this.browser.on('disconnected', () => { this.terminateBrowser(); });
/* isUnexpectedExit */
/* true */
/*         if (isUnexpectedExit) { */

/*         } */
            //await this.close();
        //await this.waitForBrowser();
        //this.countsLimitsData = countsLimitsData;
                //this.countsLimitsData = null;
/*         this.browser = false; */
            //await this.initiate(this.countsLimitsData, this.isLinkCrawlTest);
/*     waitForBrowser() {
return new Promise((resolve, reject) => {
if (reject) { }
const browserCheck = setInterval(() => {
    if (this.browser) {
        clearInterval(browserCheck);
        resolve(true);
    }
}, 100);
});
} */

// =========================

/* const puppeteerExtra = require('puppeteer-extra');
const pluginStealth = require('puppeteer-extra-plugin-stealth');
const { crawlUtils } = require('../../utils');

class PuppeteerService {

    constructor() {
        this.browser = null;
        this.page = null;
        this.pageOptions = null;
        this.waitForFunction = null;
        this.isLinkCrawlTest = null;
        this.timeout = null;
    }

    async initiate(countsLimitsData, isLinkCrawlTest) {
        this.timeout = countsLimitsData.millisecondsTimeoutSourceRequestCount;
        this.pageOptions = {
            waitUntil: 'networkidle2',
            timeout: this.timeout
        };
        this.waitForFunction = 'document.querySelector("body")';
        puppeteerExtra.use(pluginStealth());
        this.browser = await puppeteerExtra.launch({
            headless: false,
            args: [
                '--no-sandbox',
                '--disable-setuid-sandbox',
                '--disable-dev-shm-usage'
            ]
        });
        this.page = await this.browser.newPage();
        await this.page.setRequestInterception(true);
        await this.page.setJavaScriptEnabled(false);
        await this.page.setDefaultNavigationTimeout(this.timeout);
        this.page.on('request', (request) => {
            if (['image', 'stylesheet', 'font', 'script'].indexOf(request.resourceType()) !== -1) {
                request.abort();
            } else {
                request.continue();
            }
        });
        this.page.on('dialog', async dialog => {
            await dialog.dismiss();
        });
        this.isLinkCrawlTest = isLinkCrawlTest;
    }

    async crawl(link, userAgent) {
        return await new Promise(async (resolve, reject) => {
            if (reject) { }
            // Limit the runtime of this function in case of stuck URL crawling process.
            const abortTimeout = setTimeout(async () => {
                try {
                    await this.page.reload(link, this.pageOptions);
                }
                catch (error) { }
                resolve(null);
                return;
            }, this.timeout);
            if (!userAgent) {
                userAgent = crawlUtils.getRandomUserAgent();
            }
            const crawlResults = {
                isValidPage: true,
                pageSource: null
            };
            try {
                await this.page.setUserAgent(userAgent);
                await this.page.goto(link, this.pageOptions);
                await this.page.waitForFunction(this.waitForFunction, { timeout: this.timeout });
                crawlResults.pageSource = await this.page.content();
            }
            catch (error) {
                crawlResults.isValidPage = false;
            }
            if (this.isLinkCrawlTest) {
                await this.close();
            }
            clearTimeout(abortTimeout);
            resolve(crawlResults);
        }).catch();
    }

    async close() {
        if (this.browser) {
            await this.page.close();
            await this.browser.disconnect();
            await this.browser.close();
        }
    }
}

const puppeteerService = new PuppeteerService();
module.exports = puppeteerService; */

//=========================================

/*                 '--single-process',
                '--no-zygote', */
                    //await this.page.evaluate(() => window.stop());
/* ,
                '--ignore-certificate-errors',
                '--disable-accelerated-2d-canvas',
                '--disable-gpu',
                '--disable-background-timer-throttling',
                '--disable-backgrounding-occluded-windows',
                '--disable-renderer-backgrounding' */

                /* const kill = require('tree-kill');
const { crawlUtils } = require('../utils'); */
/* const puppeteerExtra = require('puppeteer-extra');
const pluginStealth = require('puppeteer-extra-plugin-stealth');

const killProcess = (pid) => {
    if (pid) {
        kill(pid);
    }
};

(async () => {
    puppeteerExtra.use(pluginStealth());
    const browser = await puppeteerExtra.launch({
        headless: false,
        args: [
            '--no-sandbox',
            '--disable-setuid-sandbox',
            '--disable-dev-shm-usage'
        ]
    });
    const pid = browser.process().pid;
    browser.on('disconnected', () => {
        killProcess(pid);
    });
    const pageOptions = {
        waitUntil: 'networkidle2',
        timeout: 60000
    };
    const page = await browser.newPage();
    const userAgent = crawlUtils.getRandomUserAgent();
    await page.setUserAgent(userAgent);
    await page.goto('http://www.google.com/', pageOptions);
    await page.waitForFunction('document.querySelector("body")');
    setInterval(() => {
        browser.close();
    }, 60000);
})();
 */

//const { textUtils } = require('../utils');
/*
    const flip = textUtils.flipDotParts('');
    console.log(flip); */
/*         var exec = require('child_process').exec;
        exec('tasklist', function(err, stdout, stderr) {
        console.log(stdout);
          // stdout is a string containing the output of the command.
          // parse it and look for the apache and mysql processes.
        }); */

/*     const exec = require('child_process').exec;

    const isRunning = (query, cb) => {
        let platform = process.platform;
        let cmd = '';
        switch (platform) {
            case 'win32': cmd = `tasklist`; break;
            case 'darwin': cmd = `ps -ax | grep ${query}`; break;
            case 'linux': cmd = `ps -A`; break;
            default: break;
        }
        exec(cmd, (err, stdout, stderr) => {
            cb(stdout.toLowerCase().indexOf(query.toLowerCase()) > -1);
        });
    };

    isRunning('Chromium', (status) => {
        console.log(status); // true|false
    }); */

    /* com.gmail@test.test => test.test@gmail.com
com.gmail@test.test => test.test@gmail.com
com.gmail@test.test => test.test@gmail.com
com.gmail@test.test => test.test@gmail.com
com.gmail@test78.test => test78.test@gmail.com */

//-Add to invalids list: test.test@template.index, test.test.test-test@template.product, test@template.account.plans
/* 'test.test@template.index', 'test.test.test-test@template.product', 'test@template.account.plans' */
//imagesloaded@4.1, flickity@2.0, webflow-util@1.0
//'font-awesome@5.11.2', 'react-dom@16.13.1', 'bootstrap@4.5.2', 'moment-duration-format@2.3.2'

/* -Find manually fix for: test@test-il.o | test@test-hr.o | test@test.c | test@test.c *
-Find the fixed domains for this: *
test@test.c, test@test.c, test@test.c, test@test.c, test@test.c, test.p@test.c, test@test.c, test@test.n *
test@test.c * */

/* const characterUtils = new CharacterUtils();
module.exports = characterUtils; */

/* const applicationUtils = new ApplicationUtils();
module.exports = applicationUtils; */

/* const colorUtils = new ColorUtils();
module.exports = colorUtils; */

/* const crawlUtils = new CrawlUtils();
module.exports = crawlUtils; */

/* const fileUtils = new FileUtils();
module.exports = fileUtils; */

/* const globalUtils = new GlobalUtils();
module.exports = globalUtils; */

/* const emailAddressUtils = new EmailAddressUtils();
module.exports = emailAddressUtils; */

/* const mongoDatabaseUtils = new MongoDatabaseUtils();
module.exports = mongoDatabaseUtils; */

/* const pathUtils = new PathUtils();
module.exports = pathUtils; */

		//this.findPackageNameRegex = /@[~^]?([\dvx*]+(?:[-.](?:[\dx*]+|alpha|beta))*)/g;
		//this.findPackageNameRegex = /(\^|\~?)(\d|x|\*)+\.(\d|x|\*)+\.(\d|x|\*)+/g;
/* const regexUtils = new RegexUtils();
module.exports = regexUtils; */

/* const logUtils = new LogUtils();
module.exports = logUtils; */

/* const textUtils = new TextUtils();
module.exports = textUtils; */
/*     cutText(data) {
        const { text, count } = data;
        if (!text) {
            return '';
        }
        return text.substring(0, count);
    } */

    /* const emailAddressesGeneratorService = new EmailAddressesGeneratorService();
module.exports = emailAddressesGeneratorService; */

/* const crawlEmailAddressService = new CrawlEmailAddressService();
module.exports = crawlEmailAddressService; */

/* const crawlLinkService = new CrawlLinkService();
module.exports = crawlLinkService; */

            //SIGKILL, SIGTERM, SIGABRT, SIGHUP, SIGINT and SIGQUIT
            /*             child.kill('SIGKILL');
                        child.kill('SIGTERM');
                        child.kill('SIGABRT');
                        child.kill('SIGINT');
                        child.kill('SIGQUIT'); */
            //child.send({action: 'close'});
/*             child.stdin.pause(); */

/*         if (this.applicationData.errorPageInARowCounter >= this.countsLimitsData.maximumErrorPageInARowCount) {
            await this.exitError(crawlInterval, 'ERROR PAGE IN A ROW', 66);
        } */
        //this.applicationData.updateErrorPageInARow(emailAddressesResult.isValidPage);
            //this.applicationData.updateErrorPageInARow(searchEngineResults.isValidPage);
            /*                     puppeteerService: puppeteerService */

            /* const settings = require('../settings/settings');
const { Color } = require('../core/enums/files/text.enum');
const { BackupType } = require('../core/enums/files/system.enum');
const { pathUtils, fileUtils, logUtils, textUtils, timeUtils } = require('../utils');
const { BackupData } = require('../core/models/application');
const globalUtils = require('../utils/files/global.utils');

class BackupLogic {

    constructor() {
        this.backupData = null;
        this.backupTitle = null;
    }

    initiate() {
        // Get the backup title from the console.
        this.backupTitle = process.argv[2];
        logUtils.logMagentaStatus('INITIATE THE BASE PARAMETERS');
        this.backupData = new BackupData(settings);
    }

    async run() {
        // Initiate the base parameters.
        this.initiate();
        // Create the backup directory.
            await this.create();
    }

    async create(backupType) {
        logUtils.logMagentaStatus(`START ${backupType} BACKUP`);
        // Set the parameters to all names and directories for the backup.
        await this.setParameters(backupType);
        // Create the backup.
        await this.runBackup(backupType);
    }

    async setParameters(backupType) {
        logUtils.logMagentaStatus(`SET THE ${backupType} PARAMETERS`);
        let backupTemporaryPath = null;
        switch (backupType) {
            case BackupType.STANDARD:
                for (let i = 0; i < this.backupData.backupMaximumDirectoryVersionsCount; i++) {
                    const backupName = textUtils.getBackupName({
                        applicationName: this.backupData.applicationName,
                        date: timeUtils.getDateNoSpaces(),
                        title: this.backupTitle,
                        index: i
                    });
                    backupTemporaryPath = pathUtils.getJoinPath({
                        targetPath: this.backupData.backupsPath,
                        targetName: textUtils.addBackslash(backupName)
                    });
                    if (!await fileUtils.isPathExists(backupTemporaryPath)) {
                        this.backupData.targetBackupName = backupName;
                        this.backupData.targetFullPath = backupTemporaryPath;
                        break;
                    }
                }
                break;
            case BackupType.SECONDARY:
                this.backupData.targetBackupName = this.backupData.applicationName;
                this.backupData.targetFullPath = this.backupData.secondaryBackupPath;
                break;
        }
    }

    async runBackup(backupType) {
        logUtils.logMagentaStatus(`RUN ${backupType} BACKUP`);
        // Validate the backup name.
        if (!this.backupData.targetBackupName) {
            throw new Error('No backup name was provided (1000001)');
        }
        if (this.backupData.targetBackupName.length <= 0) {
            throw new Error('Invalid backup name length was provided (1000002)');
        }
        // Reset the backup directory.
        await fileUtils.removeDirectoryIfExists(this.backupData.targetFullPath);
        await fileUtils.createDirectoryIfNotExists(this.backupData.targetFullPath);
        // Create the standard backup.
        await fileUtils.copyDirectory(this.backupData.sourceFullPath, this.backupData.targetFullPath, this.filterDirectories.bind(this));
        // Verify the backup directory existence.
        await this.verifyBackup(backupType);
    }

    filterDirectories(source, destination) {
        if (destination) { }
        let isIncluded = true;
        const { ignoreDirectories, ignoreFiles, includeFiles } = this.backupData.backupDirectory;
        for (let i = 0, length = ignoreDirectories.length; i < length; i++) {
            const currentPath = ignoreDirectories[i];
            isIncluded = !(source.indexOf(currentPath) > -1);
            const fileName = pathUtils.getBasename(source);
            if (includeFiles.includes(fileName)) {
                isIncluded = true;
            }
            if (ignoreFiles.includes(fileName)) {
                isIncluded = false;
            }
            if (!isIncluded) {
                break;
            }
        }
        return isIncluded;
    }

    async verifyBackup(backupType) {
        await globalUtils.sleep(this.backupData.millisecondsDelayVerifyBackupCount);
        if (!await fileUtils.isPathExists(this.backupData.targetFullPath)) {
            throw new Error('No backup was provided (1000003)');
        }
        logUtils.logColorStatus({
            status: `FINISH TO CREATE ${backupType} BACKUP: ${this.backupData.targetBackupName}`,
            color: Color.GREEN
        });
    }
}

module.exports = BackupLogic; */
/*         } */
/*         if (this.backupData.isCreateSecondaryBackup) {
            await this.create(BackupType.SECONDARY);
        } */
/*         if (this.backupData.isCreateStandardBackup) { */
/* BackupType.STANDARD */

/* IS_CREATE_STANDARD_BACKUP, IS_CREATE_SECONDARY_BACKUP, */
/* 		this.isCreateStandardBackup = IS_CREATE_STANDARD_BACKUP;
		this.isCreateSecondaryBackup = IS_CREATE_SECONDARY_BACKUP; */

        	/* 		this.errorPageInARowCounter = 0; */
/* 	updateErrorPageInARow(isValidPage) {
		this.errorPageInARowCounter = isValidPage ? 0 : this.errorPageInARowCounter + 1;
	} */

    /* const enumUtils = new EnumUtils();
module.exports = enumUtils; */

/* const domainsCounterService = new DomainsCounterService();
module.exports = domainsCounterService; */

/* const logService = new LogService();
module.exports = logService; */
//this.applicationData.errorPageInARowCounter
		//const userAgent = this.searchProcessData.pageUserAgent ? this.searchProcessData.pageUserAgent : '';

        /* const sourceService = new SourceService();
module.exports = sourceService; */

/* const searchService = new SearchService();
module.exports = searchService; */

/* const mongoDatabaseService = new MongoDatabaseService();
module.exports = mongoDatabaseService; */

/* const confirmationService = new ConfirmationService();
module.exports = confirmationService; */

/* const BackupType = enumUtils.createEnum([
    ['STANDARD', 'STANDARD'],
    ['SECONDARY', 'Secondary']
]);
 */
/* , BackupType */

/* const typosGeneratorService = new TyposGeneratorService();
module.exports = typosGeneratorService; */

/* const uuidGeneratorService = new UUIDGeneratorService();
module.exports = uuidGeneratorService; */

        //console.log(this.pid);
/*         this.pid = null; */
/* const systemUtils = new SystemUtils();
module.exports = systemUtils; */

/* const validationUtils = new ValidationUtils();
module.exports = validationUtils; */

/* const timeUtils = new TimeUtils();
module.exports = timeUtils; */

/*     // Determine if to do a normal backup to the backups directory.
    IS_CREATE_STANDARD_BACKUP: true,
    // Determine if to do a secondary copy backup to another projects directory.
    IS_CREATE_SECONDARY_BACKUP: false, */